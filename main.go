package main

import (
	"errors"
	"flag"
	"fmt"
	"log"
	"os"
	"time"
	"unsafe"

	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/ringbuf"

	"github.com/jschwinger233/bpf_ringbuf_zc_benchmark/bpf"
)

const (
	defaultEvents  = 50_000
	readTimeout    = 5 * time.Millisecond
	ringHeaderSize = 8 // sizeof(struct bpf_ringbuf_hdr)
	recordAlign    = 8 // ringbuf records are 8-byte aligned
)

var (
	eventSize *int
)

type Event = bpf.TestEvent

func main() {
	events := flag.Int("n", defaultEvents, "number of ringbuf events to generate and parse")
	mode := flag.String("mode", "both", "benchmark mode: copy | view | both")
	eventSize = flag.Int("event-size", 128, "size of each event generated by BPF program")
	flag.Parse()

	if *events <= 0 {
		log.Fatalf("event count must be > 0 (got %d)", *events)
	}

	spec, err := bpf.LoadTest()
	if err != nil {
		log.Fatalf("load bpf spec: %v", err)
	}
	param := bpf.TestParameters{
		DataSize: uint16(*eventSize - 8),
	}
	if err := spec.Variables["PARAM"].Set(&param); err != nil {
		log.Fatalf("set bpf param: %v", err)
	}

	obj := &bpf.TestObjects{}
	if err := spec.LoadAndAssign(obj, nil); err != nil {
		log.Fatalf("load and assign bpf objects: %v", err)
	}
	defer obj.Close()

	reader, err := ringbuf.NewReader(obj.MetaRingbuf)
	if err != nil {
		log.Fatalf("create ringbuf reader: %v", err)
	}
	defer reader.Close()

	recordBytes := aligned(*eventSize, recordAlign) + ringHeaderSize
	totalBytes := *events * recordBytes
	if totalBytes > reader.BufferSize() {
		log.Fatalf("ringbuf too small: need %d bytes (%d events * %d bytes) but buffer has %d bytes",
			totalBytes, *events, recordBytes, reader.BufferSize())
	}

	packet := make([]byte, *eventSize-8)

	runCopy := *mode == "copy" || *mode == "both"
	runView := *mode == "view" || *mode == "both"

	if !runCopy && !runView {
		log.Fatalf("invalid -mode %q (must be copy | view | both)", *mode)
	}

	if runCopy {
		copyDur, copyCount, copyChecksum, err := benchmark("read-into (copy)", reader, obj.Test, packet, *events, consumeRingbufCopy)
		if err != nil {
			log.Fatalf("copy benchmark: %v", err)
		}
		fmt.Printf("read-into (copy):     %d events in %s (%.2f Mevents/s), checksum=%d\n",
			copyCount, copyDur, float64(copyCount)/copyDur.Seconds()/1e6, copyChecksum)
	}

	if runView {
		zeroDur, zeroCount, zeroChecksum, err := benchmark("read-view (zero-copy)", reader, obj.Test, packet, *events, consumeRingbufView)
		if err != nil {
			log.Fatalf("zero-copy benchmark: %v", err)
		}
		fmt.Printf("read-view (zero-copy): %d events in %s (%.2f Mevents/s), checksum=%d\n",
			zeroCount, zeroDur, float64(zeroCount)/zeroDur.Seconds()/1e6, zeroChecksum)
	}
}

func benchmark(name string, reader *ringbuf.Reader, prog *ebpf.Program, packet []byte, events int, consume func(*ringbuf.Reader, int) (int, uint64, error)) (time.Duration, int, uint64, error) {
	if err := runBatch(prog, packet, events); err != nil {
		return 0, 0, 0, fmt.Errorf("%s: run bpf: %w", name, err)
	}

	reader.SetDeadline(time.Time{}) // clear any previous deadline
	start := time.Now()
	count, checksum, err := consume(reader, events)
	return time.Since(start), count, checksum, err
}

func runBatch(prog *ebpf.Program, packet []byte, repeat int) error {
	if prog == nil {
		return fmt.Errorf("nil ebpf program")
	}
	if repeat <= 0 {
		return fmt.Errorf("repeat must be positive (got %d)", repeat)
	}
	if repeat > int(^uint32(0)) {
		return fmt.Errorf("repeat too large for kernel test run: %d", repeat)
	}

	_, err := prog.Run(&ebpf.RunOptions{
		Data:   packet,
		Repeat: uint32(repeat),
	})
	return err
}

func consumeRingbufCopy(reader *ringbuf.Reader, expected int) (int, uint64, error) {
	if reader == nil {
		return 0, 0, fmt.Errorf("nil ringbuf reader")
	}

	var rec ringbuf.Record
	var count int
	var checksum uint64

	for count < expected {
		if rec.Remaining <= 0 {
			reader.SetDeadline(time.Now().Add(0))
		}

		if err := reader.ReadInto(&rec); err != nil {
			if errors.Is(err, os.ErrDeadlineExceeded) {
				return count, checksum, fmt.Errorf("timeout waiting for events: received %d/%d", count, expected)
			}
			if errors.Is(err, ringbuf.ErrClosed) || errors.Is(err, ringbuf.ErrFlushed) {
				continue
			}
			return count, checksum, fmt.Errorf("ringbuf read: %w", err)
		}

		if len(rec.RawSample) != *eventSize {
			return count, checksum, fmt.Errorf("short sample: got %d bytes, expected at least %d", len(rec.RawSample), *eventSize)
		}

		event := (*Event)(unsafe.Pointer(&rec.RawSample[0]))
		checksum += event.Skb
		count++
	}

	return count, checksum, nil
}

func consumeRingbufView(reader *ringbuf.Reader, expected int) (int, uint64, error) {
	if reader == nil {
		return 0, 0, fmt.Errorf("nil ringbuf reader")
	}

	var view ringbuf.View
	var count int
	var checksum uint64

	for count < expected {
		if view.Remaining <= 0 {
			reader.SetDeadline(time.Now().Add(5 * time.Millisecond))
		}

		if err := reader.PeekInto(&view); err != nil {
			if errors.Is(err, os.ErrDeadlineExceeded) {
				return count, checksum, fmt.Errorf("timeout waiting for events: received %d/%d", count, expected)
			}
			if errors.Is(err, ringbuf.ErrClosed) || errors.Is(err, ringbuf.ErrFlushed) {
				continue
			}
			return count, checksum, fmt.Errorf("ringbuf read view: %w", err)
		}

		if len(view.Sample) != *eventSize {
			reader.Consume(&view)

			return count, checksum, fmt.Errorf("short sample: got %d bytes, expected at least %d", len(view.Sample), *eventSize)
		}

		event := (*Event)(unsafe.Pointer(&view.Sample[0]))
		checksum += event.Skb
		count++

		reader.Consume(&view)
	}

	return count, checksum, nil
}

func aligned(n, alignment int) int {
	return (n + alignment - 1) & ^(alignment - 1)
}
